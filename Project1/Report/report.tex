% !TEX encoding = UTF-8 Unicode
% !TEX program = latexmk
% !TEX options = -xelatex -synctex=1 -shell-escape -interaction=nonstopmode -file-line-error -output-directory=out
% !TEX root = ./CT2.tex
%----------------------------------------------------------------------------------------
% Coursework/Project Requirements
% What is the mark scheme?
% Here is the thought experiment.
% Consider an external examiner (a professor from another UK
% university).
% They have heard of Lean and that know it’s a “theorem prover”.
% They have no idea how it works.
% What would they think of your project?
% Would they be able to understand something about what you
% are doing?
% Would they think “this is pretty cool, we should be teaching this
% at my university”?

% For the first project. I am looking for:
% ▶ some Lean code (150–200 lines of code including
% comments? More if you like?)
% ▶ A pdf explaining what is going on (5 pages? More if you
% like?)
% You won’t get penalised for doing too much (but it will take
% longer).
% I’m expecting about 15 (or more) hours of work.
%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
  % UTF8, % Encoding %not needed
  12pt, % Default font size, values between 10pt-12pt are allowed
  % letterpaper, % Uncomment for US letter paper size, the default paper size is a4paper
  % Chinese, % Uncomment for Chinese document
]{assignment}

\usepackage{amsthm} % For proof environment
\newtheorem{lemma}{Lemma} % define lemma environment
% \usepackage{pdfpages} % 用于插入 PDF
\usepackage{fontspec} % XeLaTeX 或 LuaLaTeX 使用 fontspec
% \usepackage{hyperref}
% \usepackage{embedfile}
% \usepackage{appendix}
\usepackage{mathtools}
\newcommand\nb{\addtocounter{equation}{1}\tag{\theequation}}
\pgfplotsset{compat=1.18}
%
% \renewcommand{\thesection}{Exercise \arabic{section}}

%

%-------------------------------------------------------------------------------
% ASSIGNMENT INFORMATION
%-------------------------------------------------------------------------------

\title{Coursework 1: Group Actions} % Assignment title

\author{Frankie Feng-Cheng WANG} % Student name

% \studentid{219046894} % Student id Leicester


\date{\today} % Due date

\institute{Department of Mathematics\\Imperial College London} % Institute or school name

\course{MATH70040-Formalising Mathematics} % Course or class name

\lecturer{Dr Bhavik Mehta} % Lecturer or teacher in charge of the assignment


%----------------------------------------------------------------------------------------
\begin{document}
\maketitle % Output the assignment title, created automatically using the information in the custom commands above
\tableofcontents

%----------------------------------------------------------------------------------------
% ASSIGNMENT CONTENT
%----------------------------------------------------------------------------------------
\section{Introduction}
This is my submission for Coursework 1 of MATH70040-Formalising Mathematics, on the topic of group actions. In this project, I formalise the definition of group actions and prove basic properties using Lean 4 with mathlib. I deliberately use a custom \texttt{GroupAction} class (rather than \texttt{MulAction}) to mirror the textbook development and keep the proofs close to the algebraic arguments.
The Main Theorm is
\begin{quote}
\textbf{Theorem:} Let \(X\) be a \(G\)-Set, for each \(g \in G\), the map \(\varphi_g : X \to X\) defined by \(\varphi_g(x) = g \cdot x\) is a permutation of \(X\). Also the map \(\Phi : G \to S_X\) defined by \(\Phi(g) = \varphi_g\) is a group homomorphism with the property that for all \(g \in G\) and \(x \in X\), \(\Phi(g)(x) = g \cdot x\).
\end{quote}
% The theorm is come from the textbook written by Fraleigh and Katz \cite{fraleigh2003first}.
% John B. Fraleigh, Victor J. Katz, *A First Course in Abstract Algebra*,
% Addison–Wesley, 2003, Section 16 (Group Actions).

\paragraph{Reader's guide.}
This report is written for an external examiner who knows abstract algebra but not Lean.
Each section contains (1) a short mathematical explanation in plain English, and
(2) a Lean excerpt that mirrors the textbook proof. The code is intentionally explicit
and avoids advanced automation, so that the steps correspond to the usual algebraic
reasoning.

\section{Background and Design Choices}
\subsection{Why a custom action class}
Mathlib already provides \texttt{MulAction}, but I define a small custom class
\texttt{GroupAction} with just two axioms: associativity of the action and the identity action.
This keeps the development minimal and makes it easy to map each Lean line to a
textbook line. The cost is that I cannot use the existing lemmas and automation for
\texttt{MulAction}, but the benefit is transparency.

\subsection{What Lean is checking}
Lean turns each statement into a typed object. When I define \texttt{sigmaPerm}, Lean
checks that the inverse function really is a two-sided inverse. When I define
\texttt{phi}, Lean checks that its image lands in the group \texttt{Equiv.Perm X},
and that multiplication is permutation composition. This explicit checking prevents
hidden gaps in the usual textbook proofs.

\section{Definitions}
In this section, I define the basic notions of group actions, including the definition of a group action, and some examples of group actions.
\subsection{Lean Code}
I first declare a minimal class for group actions:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
class GroupAction (G : Type*) [Monoid G] (X : Type*) where
  -- The action map: apply g to x.
  act : G → X → X
  -- Compatibility with multiplication in G.
  ga_mul : ∀ g₁ g₂ x, act (g₁ * g₂) x = act g₁ (act g₂ x)
  -- The identity element acts as the identity function.
  ga_one : ∀ x, act 1 x = x
\end{minted}
% 用Monoid 而不用 Group 是因为 这个Action 的定义不需要逆元的存在性。但是未来和 这块内容是Group Action 相关的定理都需要Group 所以后面我都用Group。
Note that I use \texttt{Monoid} here because the definition of a group action does not require inverses. However, since the subsequent theorems about group actions will involve groups, I will use \texttt{Group} in the later sections.


Throughout the file I work with a group \(G\) acting on a type \(X\):
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
-- Fix a group and an action instance.
variable {G : Type*} [Group G] {X : Type*} [GroupAction G X]
\end{minted}

\section{Permutation Representation}
The core construction is the map \(\sigma_g : X \to X\) given by \(\sigma_g(x) = g \cdot x\). The inverse of \(\sigma_g\) is \(\sigma_{g^{-1}}\), so \(\sigma_g\) is a permutation. This yields the permutation representation \(\phi : G \to \mathrm{Sym}(X)\).

\subsection{Proof sketch (informal)}
To show that \(\sigma_g\) is a bijection, we compute
\(\sigma_{g^{-1}}(\sigma_g(x)) = (g^{-1} g) \cdot x = 1 \cdot x = x\),
and similarly \(\sigma_g(\sigma_{g^{-1}}(x)) = x\).
Then \(\phi\) is defined by \(\phi(g) = \sigma_g\).
Multiplicativity follows from the action axiom:
\(\phi(g_1 g_2)(x) = (g_1 g_2) \cdot x = g_1 \cdot (g_2 \cdot x) = (\phi(g_1)\phi(g_2))(x)\).

\subsection{Lean Code}
First, define the underlying action map:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
/-- The action map `sigma g : X → X` given by `x ↦ g • x`. -/
def sigma (g : G) : X → X :=
  -- We use the action directly.
  fun x => GroupAction.act g x
\end{minted}

Then package it as a permutation using the inverse action:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
/-- The permutation of `X` induced by `g`, with inverse given by `g⁻¹`. -/
def sigmaPerm (g : G) : Equiv.Perm X := by
  refine
    { toFun := sigma g
      invFun := sigma g⁻¹
      left_inv := ?_
      right_inv := ?_ }
  · intro x
    calc
      -- Apply the action axiom, then cancel g⁻¹ * g.
      GroupAction.act g⁻¹ (GroupAction.act g x) =
          GroupAction.act (g⁻¹ * g) x := by
        simpa using (GroupAction.ga_mul g⁻¹ g x).symm
      _ = GroupAction.act (1 : G) x := by simp
      _ = x := GroupAction.ga_one x
  · intro x
    calc
      -- The symmetric calculation for g * g⁻¹.
      GroupAction.act g (GroupAction.act g⁻¹ x) =
          GroupAction.act (g * g⁻¹) x := by
        simpa using (GroupAction.ga_mul g g⁻¹ x).symm
      _ = GroupAction.act (1 : G) x := by simp
      _ = x := GroupAction.ga_one x
\end{minted}

Define the representation and its basic properties:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
/-- The permutation representation `phi : G → Equiv.Perm X` induced by the action. -/
def phi (g : G) : Equiv.Perm X :=
  sigmaPerm g

-- `phi` agrees with the action on elements.
lemma phi_apply (g : G) (x : X) : phi g x = GroupAction.act g x := rfl

lemma phi_mul (g₁ g₂ : G) : phi (g₁ * g₂) = phi g₁ * phi g₂ := by
  -- Reduce equality of permutations to pointwise equality.
  apply Equiv.ext
  intro x
  calc
    phi (g₁ * g₂) x = GroupAction.act (g₁ * g₂) x := rfl
    _ = GroupAction.act g₁ (GroupAction.act g₂ x) := GroupAction.ga_mul g₁ g₂ x
    _ = (phi g₁ * phi g₂) x := rfl

lemma phi_one : phi (1 : G) = (1 : Equiv.Perm X) := by
  apply Equiv.ext
  intro x
  calc
    phi (1 : G) x = GroupAction.act (1 : G) x := rfl
    _ = x := GroupAction.ga_one x
    _ = (1 : Equiv.Perm X) x := by simp [Equiv.Perm.one_apply]
\end{minted}

Finally, package the existence statement:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
-- Existence of the permutation representation with the required properties.
theorem groupActionToPermRepresentation :
  ∃ (φ : G → Equiv.Perm X),
    (∀ g x, φ g x = GroupAction.act g x) ∧
    (∀ g₁ g₂, φ (g₁ * g₂) = φ g₁ * φ g₂) ∧
    (φ 1 = 1) := by
  exact ⟨phi, ⟨phi_apply, ⟨phi_mul, phi_one⟩⟩⟩
\end{minted}

\section{Stabilizers}
For a fixed \(x \in X\), the stabilizer is the subset
\[
G_x = \{ g \in G \mid g \cdot x = x \}.
\]
In Lean this is first defined as a set, then shown to be the carrier of a subgroup, and finally packaged as a \texttt{Subgroup}.

\subsection{Proof sketch (informal)}
The identity element fixes every \(x\), so \(1 \in G_x\).
If \(g_1\) and \(g_2\) fix \(x\), then
\((g_1 g_2)\cdot x = g_1 \cdot (g_2 \cdot x) = g_1 \cdot x = x\),
so \(g_1 g_2 \in G_x\).
If \(g\) fixes \(x\), then
\(g^{-1} \cdot x = g^{-1} \cdot (g \cdot x) = (g^{-1} g) \cdot x = x\),
so \(g^{-1} \in G_x\).

\subsection{Lean Code}
Start from the set definition:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
/-- The stabilizer set `G_x = { g ∈ G | g • x = x }`. -/
def stabilizerSet (x : X) : Set G :=
  -- Membership means g fixes x.
  { g : G | GroupAction.act g x = x }
\end{minted}

Package it as a subgroup by checking closure:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
/-- The stabilizer `G_x` as a subgroup of `G`. -/
def stabilizer (x : X) : Subgroup G := by
  exact
    { carrier := stabilizerSet (G := G) (X := X) x
      one_mem' := by
        -- The identity fixes every x.
        simp [stabilizerSet, GroupAction.ga_one x]
      mul_mem' := by
        intro g₁ g₂ hg₁ hg₂
        calc
          -- Closure under multiplication uses the action axiom.
          GroupAction.act (g₁ * g₂) x = GroupAction.act g₁ (GroupAction.act g₂ x) := by
            simpa using (GroupAction.ga_mul g₁ g₂ x)
          _ = GroupAction.act g₁ x := by
            rw [hg₂]
          _ = x := hg₁
      inv_mem' := by
        intro g hg
        calc
          -- If g fixes x then g⁻¹ fixes x.
          GroupAction.act g⁻¹ x = GroupAction.act g⁻¹ (GroupAction.act g x) := by
            rw [hg]
          _ = GroupAction.act (g⁻¹ * g) x := by
            simpa using (GroupAction.ga_mul g⁻¹ g x).symm
          _ = GroupAction.act (1 : G) x := by simp
          _ = x := GroupAction.ga_one x }
\end{minted}

Then show the set is the carrier of a subgroup:
\begin{minted}[frame=lines,
  framesep=2mm,
  baselinestretch=1.2,
  fontsize=\footnotesize,
  linenos]{lean}
/-- The stabilizer set is the carrier of a subgroup of `G`. -/
theorem stabilizerSet_isSubgroup (x : X) :
    ∃ H : Subgroup G, (H : Set G) = stabilizerSet (G := G) (X := X) x := by
  refine ⟨stabilizer (G := G) (X := X) x, rfl⟩
\end{minted}
\section{Main Theorem}
The Lean development follows the textbook argument: apply \(g^{-1}\) to both sides, use associativity of the action, then use the identity axiom. The map \(g \mapsto \sigma_g\) is then a group homomorphism into the symmetric group on \(X\).

\section{Reflection}
Writing the proofs in Lean forced me to make every step explicit:
I had to specify which group identity was used, how associativity of the action is applied,
and how permutation multiplication is defined. The resulting code is not shorter than a
textbook proof, but it is far more precise. An external examiner can read the surrounding
explanations and then see that each line of code matches a specific mathematical claim.
This is the main benefit of formalisation: we trade brevity for clarity and machine-checked
correctness.

I estimate the formalisation took over fifteen hours, mostly due to understanding
Lean's typeclass resolution and the mechanics of equivalences and permutations in mathlib.
The final development is compact but captures the standard argument for the permutation
representation and the stabilizer subgroup.

\section{AI Assistance Statement}
I used AI assistance (OpenAI Codex) to help draft Lean proofs, refactor code for readability,
and produce an initial report outline. All AI-generated content was reviewed and edited by me.
I verified that the final Lean code matches the intended mathematics and that the written
explanations accurately describe the formal development.
The bibliography entry (if included) was also drafted with AI assistance, and this AI
assistance statement itself was AI-generated and then checked by me.

% Reference Section




\end{document}
