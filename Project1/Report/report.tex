% Copyright (c) 2026 Frankie Feng-Cheng WANG. All rights reserved.
% Repository: https://github.com/FrankieeW/formalising-mathematics-notes

%----------------------------------------------------------------------------------------
% Coursework/Project Requirements
% What is the mark scheme?
% Here is the thought experiment.
% Consider an external examiner (a professor from another UK
% university).
% They have heard of Lean and that know it’s a “theorem prover”.
% They have no idea how it works.
% What would they think of your project?
% Would they be able to understand something about what you
% are doing?
% Would they think “this is pretty cool, we should be teaching this
% at my university”?
%
% For the first project. I am looking for:
% ▶ some Lean code (150–200 lines of code including
% comments? More if you like?)
% ▶ A pdf explaining what is going on (5 pages? More if you
% like?)
% You won’t get penalised for doing too much (but it will take
% longer).
% I’m expecting about 15 (or more) hours of work.
%----------------------------------------------------------------------------------------
% PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
  % UTF8, % Encoding %not needed
  12pt, % Default font size, values between 10pt-12pt are allowed
  % letterpaper, % Uncomment for US letter paper size, the default paper size is a4paper
  % Chinese, % Uncomment for Chinese document
]{assignment}

\usepackage{amsthm} % For proof environment
\newtheorem{lemma}{Lemma} % define lemma environment
% \usepackage{pdfpages} % 用于插入 PDF
\usepackage{fontspec}
\setmonofont{FreeMono}
\usepackage{minted}
\newmintinline[lean]{lean4}{bgcolor=white}
\newminted[leancode]{lean4}{fontsize=\footnotesize,breaklines,breakanywhere}
\usemintedstyle{tango}
% \usepackage{hyperref}
% \usepackage{embedfile}
% \usepackage{appendix}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{xcolor}
\newcommand\nb{\addtocounter{equation}{1}\tag{\theequation}}
\pgfplotsset{compat=1.18}
% \renewcommand{\thesection}{Exercise \arabic{section}}


%-------------------------------------------------------------------------------
% ASSIGNMENT INFORMATION
%-------------------------------------------------------------------------------

\title{Coursework 1: Group Actions} % Assignment title
\author{Frankie Feng-Cheng WANG} % Student name
% \studentid{219046894} % Student id Leicester
\date{\today} % Due date
\institute{Department of Mathematics\\Imperial College London} % Institute or school name
\course{MATH70040-Formalising Mathematics} % Course or class name
\lecturer{Dr Bhavik Mehta} % Lecturer or teacher in charge of the assignment

%----------------------------------------------------------------------------------------
\begin{document}
\maketitle % Output the assignment title, created automatically using the information in the custom commands above
\tableofcontents

%----------------------------------------------------------------------------------------
% ASSIGNMENT CONTENT
%----------------------------------------------------------------------------------------
\section{Introduction}
This report formalises the theory of group actions in Lean 4. I define a custom action
class, construct the permutation representation, and prove that stabilizers form subgroups.

\subsection{Main result}
\begin{quote}
	\textbf{Theorem.} Let $X$ be a $G$-set. For each $g \in G$, the map
	$\varphi_g : X \to X$ defined by $\varphi_g(x) = g \cdot x$ is a permutation of $X$.
	The map $\Phi : G \to \mathrm{Sym}(X)$ given by $\Phi(g) = \varphi_g$ is a group
	homomorphism, and for all $g \in G$ and $x \in X$, $\Phi(g)(x) = g \cdot x$.
\end{quote}

\subsection{Why formalise group actions?}
Formalisation in Lean forces every step to be explicit: hidden assumptions become visible,
informal ``clearly'' arguments must be justified, and type checking prevents mistakes.
An external examiner familiar with group theory can read this report without prior Lean
knowledge, as each section presents the mathematics first, then shows the corresponding
Lean code. Lean's type system ensures that the permutation representation really is a
group homomorphism and that stabilizers really are subgroups---claims that informal proofs
sometimes take for granted.

\section{Background and Design Choices}
\subsection{Why a custom action class}
Mathlib already provides \texttt{MulAction}, but I define a small custom class
\texttt{GroupAction} with just two axioms: compatibility with multiplication and
the identity action. This keeps the development minimal and makes it easy to map
Lean lines to textbook lines. The cost is that I cannot use existing \texttt{MulAction}
lemmas, but the benefit is transparency.

\subsection{What Lean is checking}
Lean treats each statement as a typed object. When I define \texttt{sigmaPerm}, Lean
checks that the inverse function is a two-sided inverse. When I define \texttt{phi},
Lean checks that its image lies in the group \texttt{Equiv.Perm X} and that
multiplication is permutation composition. This explicit checking prevents hidden
gaps that can slip into informal proofs.

\section{Definitions}
This section introduces the group action class and the standing assumptions used
throughout the file.

\subsection{Lean code}
I first declare a minimal class for group actions:
\begin{leancode}
	class GroupAction (G : Type*) [Monoid G] (X : Type*) where
	-- The action map: apply g to x.
	act : G → X → X
	-- Compatibility with multiplication in G.
	ga_mul : ∀ g₁ g₂ x, act (g₁ * g₂) x = act g₁ (act g₂ x)
	-- The identity element acts as the identity function.
	ga_one : ∀ x, act 1 x = x
\end{leancode}
Note that I use \texttt{Monoid} here because the definition of a group action does not
require inverses. Later results about permutation representations and stabilizers
require a \texttt{Group}, so the subsequent sections assume \texttt{[Group G]}.

Throughout the file I work with a group $G$ acting on a type $X$:
\begin{leancode}
	-- Fix a group and an action instance.
	variable {G : Type*} [Group G] {X : Type*} [GroupAction G X]
\end{leancode}

\section{Concrete Examples of Group Actions}
This section presents six concrete instances of the \texttt{GroupAction} class,
illustrating how the abstract definition applies to familiar mathematical structures.

\subsection{Symmetric group acting on a set}
Let $X$ be any type. The symmetric group $\mathrm{Sym}(X)$ acts on $X$ by evaluation:
for $\sigma \in \mathrm{Sym}(X)$ and $x \in X$, define $\sigma \cdot x := \sigma(x)$.

\begin{leancode}
	instance permGroupAction {X : Type*} : GroupAction (Equiv.Perm X) X :=
	{ act := fun g x => g x
	ga_mul := by
	intro g1 g2 x
	rfl
	ga_one := by
	intro x
	rfl }
\end{leancode}

The axiom proofs are immediate by reflexivity: composition of permutations and function
evaluation commute definitionally in Lean.

\subsection{Group acting on itself by left multiplication}
Every group $G$ acts on itself by left multiplication: $g_1 \cdot g_2 := g_1 * g_2$.

\begin{leancode}
	instance groupAsGSet {G : Type*} [Group G] : GroupAction G G :=
	{ act := fun g1 g2 => g1 * g2
	ga_mul := by
	intro g1 g2 g3
	rw [mul_assoc]
	ga_one := by
	intro g
	rw [one_mul] }
\end{leancode}

The \texttt{ga\_mul} axiom follows from associativity of group multiplication, and
\texttt{ga\_one} from the identity axiom.

\subsection{Subgroup acting on the group}
A subgroup $H \leq G$ acts on $G$ by left multiplication. Elements of $H$ are coerced
to elements of $G$ using \texttt{(h : G)}.

\begin{leancode}
	instance subgroupAsGSet {G : Type*} [Group G] (H : Subgroup G) : GroupAction H G :=
	{ act := fun h g => (h : G) * g
	ga_mul := by
	intros
	simp [mul_assoc]
	ga_one := by
	intros
	simp }
\end{leancode}

The \texttt{simp} tactic handles the coercion and applies associativity and identity axioms.

\subsection{Conjugation action of a subgroup on itself}
A subgroup $H$ acts on itself by conjugation: $h_1 \cdot h_2 := h_1 h_2 h_1^{-1}$.

\begin{leancode}
	instance subgroupAsGSet_conjugation {G : Type*} [Group G] (H : Subgroup G) : GroupAction H H :=
	{ act := fun h g => h * g * h⁻¹
	ga_mul := by
	intro g₁ g₂ g₃
	simp
	rw [← mul_assoc g₁]
	rw [mul_assoc g₁ g₂]
	rw [← mul_assoc]
	ga_one := by
	intros
	simp }
\end{leancode}

The \texttt{ga\_mul} proof rearranges terms using associativity to show
$(g_1 g_2) \cdot g_3 = g_1 \cdot (g_2 \cdot g_3)$ under conjugation.

\subsection{Scalar action on complex vector spaces}
The multiplicative group $\mathbb{C}^\times$ of nonzero complex numbers acts on
$\mathbb{C}^n$ by scalar multiplication.

\begin{leancode}
	instance vectorSpaceAsCStarSet (n : ℕ) : GroupAction (ℂˣ) (Fin n → ℂ) :=
	{ act := fun r v => fun i => (r : ℂ) * v i
	ga_mul := by
	intros r1 r2 v
	ext i
	simp [mul_assoc]
	ga_one := by
	intro v
	ext i
	simp }
\end{leancode}

Here \texttt{ℂˣ} denotes the units of $\mathbb{C}$ (invertible elements), and
\texttt{Fin n → ℂ} represents functions from $\{0, \ldots, n-1\}$ to $\mathbb{C}$
(i.e., $n$-dimensional complex vectors). The \texttt{ext} tactic proves function equality
pointwise.

\subsection{Scalar action on real vector spaces}
Similarly, $\mathbb{R}^\times$ acts on $\mathbb{R}^n$ by scalar multiplication.

\begin{leancode}
	instance vectorSpaceAsRStarSet (n : ℕ) : GroupAction (ℝˣ) (Fin n → ℝ) :=
	{ act := fun r v => fun i => (r : ℝ) * v i
	ga_mul := by
	intros r1 r2 v
	ext i
	simp [mul_assoc]
	ga_one := by
	intro v
	ext i
	simp }
\end{leancode}

The structure is identical to the complex case, with $\mathbb{R}$ replacing $\mathbb{C}$.

\section{Permutation Representation}
The core construction is the map $\sigma_g : X \to X$ given by $\sigma_g(x) = g \cdot x$.
The inverse of $\sigma_g$ is $\sigma_{g^{-1}}$, so $\sigma_g$ is a permutation.
This yields the permutation representation $\phi : G \to \mathrm{Sym}(X)$.

\subsection{Proof sketch (informal)}
To show that $\sigma_g$ is a bijection, compute
$\sigma_{g^{-1}}(\sigma_g(x)) = (g^{-1} g) \cdot x = 1 \cdot x = x$, and similarly
$\sigma_g(\sigma_{g^{-1}}(x)) = x$. The representation is defined by
$\phi(g) = \sigma_g$, and multiplicativity follows from the action axiom:
\[
	\phi(g_1 g_2)(x) = (g_1 g_2) \cdot x = g_1 \cdot (g_2 \cdot x) = (\phi(g_1)\phi(g_2))(x).
\]

\subsection{Lean code}
First, define the underlying action map:
\begin{leancode}
	/-- The action map `sigma g : X → X`
	given by `x ↦ g • x`. -/
	def sigma (g : G) : X → X :=
	-- We use the action directly.
	fun x => GroupAction.act g x
\end{leancode}

Then package it as a permutation using the inverse action:
\begin{leancode}
	/-- The permutation of `X` induced by `g`,
	with inverse given by `g⁻¹`. -/
	def sigmaPerm (g : G) : Equiv.Perm X := by
	refine
		{ toFun := sigma g
			invFun := sigma g⁻¹
			left_inv := ?_
			right_inv := ?_ }
	· intro x
	calc
	-- Apply the action axiom, then cancel g⁻¹ * g.
	GroupAction.act g⁻¹ (GroupAction.act g x) =
	GroupAction.act (g⁻¹ * g) x := by
	simpa using (GroupAction.ga_mul g⁻¹ g x).symm
	_ = GroupAction.act (1 : G) x := by simp
	_ = x := GroupAction.ga_one x
	· intro x
	calc
	-- The symmetric calculation for g * g⁻¹.
	GroupAction.act g (GroupAction.act g⁻¹ x) =
	GroupAction.act (g * g⁻¹) x := by
	simpa using (GroupAction.ga_mul g g⁻¹ x).symm
	_ = GroupAction.act (1 : G) x := by simp
	_ = x := GroupAction.ga_one x
\end{leancode}

Define the representation and its basic properties:
\begin{leancode}
	/-- The permutation representation `phi : G → Equiv.Perm X`
	induced by the action. -/
	def phi (g : G) : Equiv.Perm X :=
	sigmaPerm g

	-- `phi` agrees with the action on elements.
	lemma phi_apply (g : G) (x : X) : phi g x = GroupAction.act g x := rfl

	lemma phi_mul (g₁ g₂ : G) : phi (g₁ * g₂) = phi g₁ * phi g₂ := by
	-- Reduce equality of permutations to pointwise equality.
	apply Equiv.ext
	intro x
	calc
	phi (g₁ * g₂) x = GroupAction.act (g₁ * g₂) x := rfl
	_ = GroupAction.act g₁ (GroupAction.act g₂ x) := GroupAction.ga_mul g₁ g₂ x
	_ = (phi g₁ * phi g₂) x := rfl

	lemma phi_one : phi (1 : G) = (1 : Equiv.Perm X) := by
	apply Equiv.ext
	intro x
	calc
	phi (1 : G) x = GroupAction.act (1 : G) x := rfl
	_ = x := GroupAction.ga_one x
	_ = (1 : Equiv.Perm X) x := by simp [Equiv.Perm.one_apply]
\end{leancode}

Finally, package the existence statement:
\begin{leancode}
	-- Existence of the permutation representation with the required properties.
	theorem group_action_to_perm_representation :
	∃ (φ : G → Equiv.Perm X),
	(∀ g x, φ g x = GroupAction.act g x) ∧
	(∀ g₁ g₂, φ (g₁ * g₂) = φ g₁ * φ g₂) ∧
	(φ 1 = 1) := by
	exact ⟨phi, ⟨phi_apply, ⟨phi_mul, phi_one⟩⟩⟩
\end{leancode}

\section{Stabilizers}
For a fixed $x \in X$, the stabilizer is the subset
\[
	G_x = \{ g \in G \mid g \cdot x = x \}.
\]
In Lean this is first defined as a set, then shown to be the carrier of a subgroup,
and finally packaged as a \texttt{Subgroup}.

\subsection{Proof sketch (informal)}
The identity element fixes every $x$, so $1 \in G_x$. If $g_1$ and $g_2$ fix $x$, then
$(g_1 g_2)\cdot x = g_1 \cdot (g_2 \cdot x) = g_1 \cdot x = x$, so $g_1 g_2 \in G_x$.
If $g$ fixes $x$, then
$g^{-1} \cdot x = g^{-1} \cdot (g \cdot x) = (g^{-1} g) \cdot x = x$,
so $g^{-1} \in G_x$.

\subsection{Lean code}
Start from the set definition:
\begin{leancode}
	/-- The stabilizer set
	`G_x = { g ∈ G | g • x = x }`. -/
	def stabilizerSet (x : X) : Set G :=
	-- Membership means g fixes x.
		{ g : G | GroupAction.act g x = x }
\end{leancode}

Package it as a subgroup by checking closure:
\begin{leancode}
	/-- The stabilizer `G_x` as a subgroup of `G`. -/
	def stabilizer (x : X) : Subgroup G := by
	exact
		{ carrier := stabilizerSet (G := G) (X := X) x
			one_mem' := by
			-- The identity fixes every x.
			simp [stabilizerSet, GroupAction.ga_one x]
			mul_mem' := by
			intro g₁ g₂ hg₁ hg₂
			calc
			-- Closure under multiplication uses the action axiom.
			GroupAction.act (g₁ * g₂) x = GroupAction.act g₁ (GroupAction.act g₂ x) := by
			simpa using (GroupAction.ga_mul g₁ g₂ x)
			_ = GroupAction.act g₁ x := by
			rw [hg₂]
			_ = x := hg₁
			inv_mem' := by
			intro g hg
			calc
			-- If g fixes x then g⁻¹ fixes x.
			GroupAction.act g⁻¹ x = GroupAction.act g⁻¹ (GroupAction.act g x) := by
			rw [hg]
			_ = GroupAction.act (g⁻¹ * g) x := by
			simpa using (GroupAction.ga_mul g⁻¹ g x).symm
			_ = GroupAction.act (1 : G) x := by simp
			_ = x := GroupAction.ga_one x }
\end{leancode}

Then show the set is the carrier of a subgroup:
\begin{leancode}
	/-- The stabilizer set is the carrier of a subgroup of `G`. -/
	theorem stabilizer_set_is_subgroup (x : X) :
	∃ H : Subgroup G, (H : Set G) = stabilizerSet (G := G) (X := X) x := by
	refine ⟨stabilizer (G := G) (X := X) x, rfl⟩
\end{leancode}

\section{Main Theorem}
The Lean theorem \texttt{group\_action\_to\_perm\_representation} packages the permutation
representation together with its key properties. The proof uses the lemmas from the
previous section: \texttt{phi\_apply}, \texttt{phi\_mul}, and \texttt{phi\_one}.

\section{What Lean Guarantees}
Formalizing these constructions in Lean provides guarantees that informal proofs cannot match.
When Lean accepts a definition or theorem, it has verified:
\begin{itemize}
	\item \textbf{Types are correct.} The function \texttt{phi : G → Equiv.Perm X} has the claimed type.
	      Lean checks that \texttt{sigmaPerm g} is actually a permutation (a bijection), not just a function.
	      If we mistakenly defined a non-bijective map, Lean would reject it.
	\item \textbf{No hidden assumptions.} Every lemma explicitly lists its hypotheses. If a proof uses
	      associativity, the code must invoke \texttt{mul\_assoc} or the \texttt{ga\_mul} axiom.
	      There are no ``clearly'' or ``it follows that'' steps that skip justification.
	\item \textbf{Axioms match definitions.} The \texttt{GroupAction} class requires \texttt{ga\_mul}
	      and \texttt{ga\_one}. If we omitted \texttt{ga\_one}, the proof of \texttt{phi\_one} would fail
	      because Lean would have no way to show $1 \cdot x = x$.
	\item \textbf{Subgroup structure is verified.} When we package the stabilizer as a \texttt{Subgroup},
	      Lean checks that we provided proofs of closure under multiplication, inverses, and identity.
	      The type system prevents us from claiming ``the stabilizer is a subgroup'' without proving it.
\end{itemize}

These checks prevent common errors: mistaken claims about injectivity, forgotten hypotheses,
and gaps in subgroup proofs. An external examiner can trust that the Lean code genuinely establishes
the mathematical claims, not just that it compiles.

\section{Reflection}
Writing the proofs in Lean forced me to make every step explicit. In particular:
\begin{itemize}
	\item I had to specify exactly where associativity of the action is used.
	\item I had to show explicitly that $\sigma_{g^{-1}}$ is an inverse.
	\item I had to unfold the definition of permutation multiplication.
\end{itemize}
The resulting code is not shorter than a textbook proof, but it is more precise.
An external examiner can read the surrounding explanations and then see that each
Lean line matches a specific mathematical claim.

I estimate the formalisation took over fifteen hours, mostly due to understanding
Lean's typeclass resolution and the mechanics of equivalences and permutations in
mathlib. The final development is compact but captures the standard argument for the
permutation representation and the stabilizer subgroup.

\subsection{Specific challenges encountered}
Several technical hurdles emerged during the formalization:
\begin{itemize}
	\item \textbf{Typeclass resolution:} Ensuring Lean could automatically find the \texttt{GroupAction}
	      instance in complex contexts required careful use of explicit type annotations (e.g., \texttt{(G := G)}).
	\item \textbf{Equivalence mechanics:} Constructing \texttt{sigmaPerm} as an \texttt{Equiv.Perm X}
	      required providing both \texttt{left\_inv} and \texttt{right\_inv} proofs, which meant carefully
	      applying the \texttt{ga\_mul} axiom in both directions.
	\item \textbf{Coercions:} Working with subgroups required understanding how Lean coerces elements
	      of type \texttt{H} (a subgroup) to type \texttt{G} (the ambient group) using \texttt{(h : G)}.
	\item \textbf{Function extensionality:} Proving equality of permutations required \texttt{Equiv.ext},
	      and equality of vector-valued functions required \texttt{ext i}, which were not immediately obvious.
\end{itemize}

\subsection{Potential extensions}
This development could be extended in several directions:
\begin{itemize}
	\item \textbf{Orbit-stabilizer theorem:} Formalize the relationship $|G| = |\text{Orb}(x)| \cdot |G_x|$
	      for finite groups, which requires defining orbits and proving Lagrange's theorem.
	\item \textbf{Burnside's lemma:} Count orbits using the formula involving fixed points.
	\item \textbf{Actions on cosets:} Show that a group acts on the left cosets of a subgroup,
	      yielding the standard permutation representation.
	\item \textbf{Cayley's theorem:} Specialize the permutation representation to the case where
	      $G$ acts on itself, proving every group embeds in a symmetric group.
\end{itemize}

\section{AI Assistance Statement}
I used AI assistance to help draft Lean proofs and improve code readability. All
AI-generated content was reviewed and verified by me to ensure mathematical accuracy.

\section{References}
John B. Fraleigh, Victor J. Katz, \textit{A First Course in Abstract Algebra},
Addison--Wesley, 2003, Section 16 (Group Actions).

\end{document}
